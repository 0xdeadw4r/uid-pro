import {
  Client,
  GatewayIntentBits,
  REST,
  Routes,
  SlashCommandBuilder,
  EmbedBuilder,
  CommandInteraction,
  ChatInputCommandInteraction,
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ButtonInteraction,
  ComponentType,
} from "discord.js";
import { readFileSync, writeFileSync, existsSync, appendFileSync } from "fs";
import { config } from "./config";

const GENZAUTH_API_BASE = "https://genzauth-tl0c.onrender.com/api/seller";

interface GenzAuthResponse {
  success?: boolean;
  message?: string;
  error?: string;
  license?: string;
  licenses?: any[];
  users?: any[];
  [key: string]: any;
}

interface LogEntry {
  timestamp: string;
  user: string;
  userId: string;
  operation: string;
  target?: string;
  success: boolean;
  message: string;
}

class BotLogger {
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;
  private logFile: string = 'discord-bot-audit.log';

  constructor() {
    this.loadLogsFromFile();
  }

  private loadLogsFromFile() {
    try {
      if (existsSync(this.logFile)) {
        const data = readFileSync(this.logFile, 'utf-8');
        const lines = data.trim().split('\n').filter((line: string) => line);
        this.logs = lines.map((line: string) => JSON.parse(line));
        console.log(`‚úÖ Loaded ${this.logs.length} log entries from file`);
      }
    } catch (error) {
      console.error('‚ùå Error loading logs from file:', error);
    }
  }

  private appendToFile(entry: LogEntry) {
    try {
      appendFileSync(this.logFile, JSON.stringify(entry) + '\n');
    } catch (error) {
      console.error('‚ùå Error writing log to file:', error);
    }
  }

  log(entry: Omit<LogEntry, 'timestamp'>) {
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      ...entry,
    };

    this.logs.push(logEntry);

    // Keep only the most recent logs in memory
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }

    // Persist to file
    this.appendToFile(logEntry);

    // Console logging for real-time monitoring
    const status = entry.success ? '‚úÖ' : '‚ùå';
    console.log(
      `[BOT LOG] ${status} ${entry.operation} by ${entry.user} (${entry.userId})` +
      (entry.target ? ` - Target: ${entry.target}` : '') +
      ` - ${entry.message}`
    );
  }

  getLogs(limit: number = 50): LogEntry[] {
    return this.logs.slice(-limit);
  }

  getLogsByUser(userId: string, limit: number = 50): LogEntry[] {
    return this.logs.filter(log => log.userId === userId).slice(-limit);
  }

  getLogsByOperation(operation: string, limit: number = 50): LogEntry[] {
    return this.logs.filter(log => log.operation === operation).slice(-limit);
  }

  clearLogs() {
    this.logs = [];
  }
}

class GenzAuthAPI {
  private sellerKey: string;

  constructor(sellerKey: string) {
    this.sellerKey = sellerKey;
  }

  private async makeRequest(
    type: string,
    additionalParams: Record<string, string> = {}
  ): Promise<GenzAuthResponse> {
    const params = new URLSearchParams({
      sellerkey: this.sellerKey,
      type,
      format: "json",
      ...additionalParams,
    });

    const url = `${GENZAUTH_API_BASE}?${params.toString()}`;
    const safeUrl = url.replace(this.sellerKey, "***HIDDEN***");

    console.log(`[GenzAuth API] Request: ${safeUrl}`);

    try {
      const response = await fetch(url);
      
      console.log(`[GenzAuth API] Response Status: ${response.status} ${response.statusText}`);
      
      if (!response.ok) {
        const errorText = await response.text().catch(() => "Unable to read response");
        console.error(`[GenzAuth API] Error Response: ${errorText}`);
        return {
          success: false,
          error: `HTTP ${response.status}: ${response.statusText} - ${errorText}`,
        };
      }

      const responseText = await response.text();
      console.log(`[GenzAuth API] Response Body (first 200 chars): ${responseText.substring(0, 200)}`);
      
      try {
        const jsonResponse = JSON.parse(responseText);
        console.log(`[GenzAuth API] Parsed JSON success: ${jsonResponse.success}`);
        return jsonResponse;
      } catch (parseError) {
        console.error(`[GenzAuth API] JSON Parse Error:`, parseError);
        console.error(`[GenzAuth API] Raw Response: ${responseText}`);
        return {
          success: false,
          error: "Invalid JSON response from API",
        };
      }
    } catch (error) {
      console.error(`[GenzAuth API] Network Error:`, error);
      if (error instanceof Error) {
        console.error(`[GenzAuth API] Error Name: ${error.name}`);
        console.error(`[GenzAuth API] Error Message: ${error.message}`);
        console.error(`[GenzAuth API] Error Stack:`, error.stack);
        if ('cause' in error) {
          console.error(`[GenzAuth API] Error Cause:`, error.cause);
        }
      }
      return {
        success: false,
        error: error instanceof Error ? error.message : "Network request failed",
      };
    }
  }

  async addLicense(expiry: number, amount: number = 1) {
    return this.makeRequest("add", {
      expiry: expiry.toString(),
      amount: amount.toString(),
    });
  }

  async verifyLicense(license: string) {
    return this.makeRequest("verify", { license });
  }

  async activateLicense(license: string, hwid: string) {
    return this.makeRequest("activate", { license, hwid });
  }

  async deleteLicense(license: string) {
    return this.makeRequest("del", { license });
  }

  async banLicense(license: string) {
    return this.makeRequest("ban", { license });
  }

  async fetchAllUsers() {
    return this.makeRequest("fetchallusers");
  }

  async createUser(username: string, password: string, expiry: number) {
    return this.makeRequest("createuser", { 
      username, 
      password,
      expiry: expiry.toString()
    });
  }

  async banUser(username: string) {
    return this.makeRequest("banuser", { user: username });
  }

  async unbanUser(username: string) {
    return this.makeRequest("unbanuser", { user: username });
  }

  async deleteUser(username: string) {
    return this.makeRequest("deluser", { user: username });
  }

  async extendUser(username: string, days: number) {
    return this.makeRequest("extenduser", { user: username, days: days.toString() });
  }

  async resetHwid(username: string) {
    return this.makeRequest("resethwid", { user: username });
  }

  async fetchAllLicenses() {
    return this.makeRequest("fetchalllicenses");
  }
}

class DiscordBot {
  private client: Client;
  private genzAuth: GenzAuthAPI;
  private commands: any[];
  private token: string;
  private logger: BotLogger;

  constructor(token: string, sellerKey: string) {
    this.token = token;
    this.logger = new BotLogger();
    this.client = new Client({
      intents: [GatewayIntentBits.Guilds],
    });

    this.genzAuth = new GenzAuthAPI(sellerKey);
    this.commands = this.buildCommands();

    this.setupEventHandlers();
  }

  private buildCommands() {
    return [
      new SlashCommandBuilder()
        .setName("help")
        .setDescription("Show all available commands and their usage"),

      new SlashCommandBuilder()
        .setName("add-license")
        .setDescription("Create new license(s)")
        .addIntegerOption((option) =>
          option
            .setName("expiry")
            .setDescription("License expiry in days")
            .setRequired(true)
        )
        .addIntegerOption((option) =>
          option
            .setName("amount")
            .setDescription("Number of licenses to create (default: 1)")
            .setRequired(false)
        ),

      new SlashCommandBuilder()
        .setName("verify-license")
        .setDescription("Verify a license key")
        .addStringOption((option) =>
          option
            .setName("license")
            .setDescription("License key to verify")
            .setRequired(true)
        ),

      new SlashCommandBuilder()
        .setName("activate-license")
        .setDescription("Activate a license with HWID")
        .addStringOption((option) =>
          option
            .setName("license")
            .setDescription("License key to activate")
            .setRequired(true)
        )
        .addStringOption((option) =>
          option
            .setName("hwid")
            .setDescription("Hardware ID")
            .setRequired(true)
        ),

      new SlashCommandBuilder()
        .setName("delete-license")
        .setDescription("Delete a license (Admin Only)")
        .addStringOption((option) =>
          option
            .setName("license")
            .setDescription("License key to delete")
            .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

      new SlashCommandBuilder()
        .setName("ban-license")
        .setDescription("Ban a license (Admin Only)")
        .addStringOption((option) =>
          option
            .setName("license")
            .setDescription("License key to ban")
            .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

      new SlashCommandBuilder()
        .setName("fetch-users")
        .setDescription("Fetch all users"),

      new SlashCommandBuilder()
        .setName("create-user")
        .setDescription("Create a new user")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username for the new user")
            .setRequired(true)
        )
        .addStringOption((option) =>
          option
            .setName("password")
            .setDescription("Password for the new user")
            .setRequired(true)
        )
        .addIntegerOption((option) =>
          option
            .setName("expiry")
            .setDescription("User expiry in days")
            .setRequired(true)
        ),

      new SlashCommandBuilder()
        .setName("ban-user")
        .setDescription("Ban a user (Admin Only)")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username to ban")
            .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

      new SlashCommandBuilder()
        .setName("unban-user")
        .setDescription("Unban a user (Admin Only)")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username to unban")
            .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

      new SlashCommandBuilder()
        .setName("delete-user")
        .setDescription("Delete a user (Admin Only)")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username to delete")
            .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

      new SlashCommandBuilder()
        .setName("extend-user")
        .setDescription("Extend user subscription")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username to extend")
            .setRequired(true)
        )
        .addIntegerOption((option) =>
          option
            .setName("days")
            .setDescription("Number of days to extend")
            .setRequired(true)
        ),

      new SlashCommandBuilder()
        .setName("reset-hwid")
        .setDescription("Reset user HWID")
        .addStringOption((option) =>
          option
            .setName("username")
            .setDescription("Username to reset HWID for")
            .setRequired(true)
        ),

      new SlashCommandBuilder()
        .setName("fetch-licenses")
        .setDescription("Fetch all licenses"),
    ];
  }

  private createEmbed(
    title: string,
    description: string,
    color: "success" | "error" | "info" | "warning"
  ): EmbedBuilder {
    const colors = {
      success: 0x43b581,
      error: 0xf04747,
      info: 0x5865f2,
      warning: 0xfaa61a,
    };

    return new EmbedBuilder()
      .setTitle(title)
      .setDescription(description)
      .setColor(colors[color])
      .setTimestamp()
      .setFooter({ text: "GenzAuth Bot" });
  }

  private createSuccessEmbed(title: string, description: string): EmbedBuilder {
    return this.createEmbed(`‚úÖ ${title}`, description, "success");
  }

  private createErrorEmbed(title: string, description: string): EmbedBuilder {
    return this.createEmbed(`‚ùå ${title}`, description, "error");
  }

  private createInfoEmbed(title: string, description: string): EmbedBuilder {
    return this.createEmbed(`‚ÑπÔ∏è ${title}`, description, "info");
  }

  private createPaginationButtons(
    currentPage: number,
    totalPages: number,
    customId: string
  ): ActionRowBuilder<ButtonBuilder> {
    const row = new ActionRowBuilder<ButtonBuilder>();

    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`${customId}_prev_${currentPage}`)
        .setLabel("‚óÄ Previous")
        .setStyle(ButtonStyle.Primary)
        .setDisabled(currentPage === 0),
      new ButtonBuilder()
        .setCustomId(`${customId}_page_${currentPage}`)
        .setLabel(`Page ${currentPage + 1}/${totalPages}`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(true),
      new ButtonBuilder()
        .setCustomId(`${customId}_next_${currentPage}`)
        .setLabel("Next ‚ñ∂")
        .setStyle(ButtonStyle.Primary)
        .setDisabled(currentPage >= totalPages - 1)
    );

    return row;
  }

  private createConfirmationButtons(
    action: string,
    target: string,
    userId: string
  ): ActionRowBuilder<ButtonBuilder> {
    const row = new ActionRowBuilder<ButtonBuilder>();

    const payload = Buffer.from(JSON.stringify({ target, userId })).toString('base64');

    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`confirm:::${action}:::${payload}`)
        .setLabel("‚úì Confirm")
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId(`cancel:::${action}:::${payload}`)
        .setLabel("‚úó Cancel")
        .setStyle(ButtonStyle.Secondary)
    );

    return row;
  }

  private setupEventHandlers() {
    this.client.on("ready", () => {
      console.log(`‚úÖ Discord bot logged in as ${this.client.user?.tag}`);
    });

    this.client.on("interactionCreate", async (interaction) => {
      if (interaction.isChatInputCommand()) {
        await this.handleCommand(interaction);
      } else if (interaction.isButton()) {
        await this.handleButtonInteraction(interaction);
      }
    });
  }

  private async handleCommand(interaction: ChatInputCommandInteraction) {
    await interaction.deferReply();

    // Log command receipt
    const user = interaction.user;
    this.logger.log({
      user: user.username,
      userId: user.id,
      operation: `COMMAND_${interaction.commandName.toUpperCase().replace(/-/g, '_')}`,
      success: true,
      message: `Command initiated`,
    });

    try {
      switch (interaction.commandName) {
        case "help":
          await this.handleHelp(interaction);
          break;
        case "add-license":
          await this.handleAddLicense(interaction);
          break;
        case "verify-license":
          await this.handleVerifyLicense(interaction);
          break;
        case "activate-license":
          await this.handleActivateLicense(interaction);
          break;
        case "delete-license":
          await this.handleDeleteLicense(interaction);
          break;
        case "ban-license":
          await this.handleBanLicense(interaction);
          break;
        case "fetch-users":
          await this.handleFetchUsers(interaction);
          break;
        case "create-user":
          await this.handleCreateUser(interaction);
          break;
        case "ban-user":
          await this.handleBanUser(interaction);
          break;
        case "unban-user":
          await this.handleUnbanUser(interaction);
          break;
        case "delete-user":
          await this.handleDeleteUser(interaction);
          break;
        case "extend-user":
          await this.handleExtendUser(interaction);
          break;
        case "reset-hwid":
          await this.handleResetHwid(interaction);
          break;
        case "fetch-licenses":
          await this.handleFetchLicenses(interaction);
          break;
        default:
          await interaction.editReply({
            embeds: [
              this.createErrorEmbed(
                "Unknown Command",
                "This command is not recognized."
              ),
            ],
          });
      }
    } catch (error) {
      console.error("Command error:", error);

      this.logger.log({
        user: interaction.user.username,
        userId: interaction.user.id,
        operation: `ERROR_${interaction.commandName.toUpperCase().replace(/-/g, '_')}`,
        success: false,
        message: error instanceof Error ? error.message : "Unknown error occurred",
      });

      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Error",
            `An error occurred: ${error instanceof Error ? error.message : "Unknown error"}`
          ),
        ],
      });
    }
  }

  private async handleHelp(interaction: ChatInputCommandInteraction) {
    const embed = this.createInfoEmbed(
      "GenzAuth Bot - Command Help",
      "Professional license management bot for GenzAuth"
    );

    embed.addFields(
      {
        name: "üîë License Commands",
        value:
          "`/add-license` - Create new license(s)\n" +
          "`/verify-license` - Verify a license key\n" +
          "`/activate-license` - Activate license with HWID\n" +
          "`/delete-license` - Delete a license\n" +
          "`/ban-license` - Ban a license\n" +
          "`/fetch-licenses` - Fetch all licenses",
        inline: false,
      },
      {
        name: "üë§ User Management",
        value:
          "`/create-user` - Create a new user\n" +
          "`/fetch-users` - Fetch all users\n" +
          "`/ban-user` - Ban a user\n" +
          "`/unban-user` - Unban a user\n" +
          "`/delete-user` - Delete a user\n" +
          "`/extend-user` - Extend user subscription\n" +
          "`/reset-hwid` - Reset user HWID",
        inline: false,
      },
      {
        name: "‚ÑπÔ∏è Information",
        value: "`/help` - Show this help menu",
        inline: false,
      }
    );

    await interaction.editReply({ embeds: [embed] });
  }

  private async handleAddLicense(interaction: ChatInputCommandInteraction) {
    const expiry = interaction.options.getInteger("expiry", true);
    const amount = interaction.options.getInteger("amount") || 1;

    const result = await this.genzAuth.addLicense(expiry, amount);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "License Created",
        result.message || "License(s) created successfully"
      );

      // API returns licenses in result.data array
      if (result.data && Array.isArray(result.data) && result.data.length > 0) {
        const licenseList = result.data
          .map((licenseKey: string, index: number) => {
            return `${index + 1}. \`${licenseKey}\``;
          })
          .join("\n");

        embed.addFields({
          name: amount > 1 ? `License Keys (${result.data.length})` : "License Key",
          value: licenseList,
          inline: false,
        });
      }

      embed.addFields(
        { name: "Expiry", value: `${expiry} days`, inline: true },
        { name: "Amount", value: `${amount}`, inline: true }
      );

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Failed to Create License",
            result.error || result.message || "Unknown error"
          ),
        ],
      });
    }
  }

  private async handleVerifyLicense(interaction: ChatInputCommandInteraction) {
    const license = interaction.options.getString("license", true);

    const result = await this.genzAuth.verifyLicense(license);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "License Verified",
        result.message || "License is valid and active"
      );

      embed.addFields({
        name: "License Key",
        value: `\`${license}\``,
        inline: false,
      });

      // API returns license data in result.data as an array
      // Extract the first element if it's an array, otherwise use result.data
      let licenseData;
      if (result.data && Array.isArray(result.data)) {
        licenseData = result.data[0];
      } else if (result.data) {
        licenseData = result.data;
      } else {
        licenseData = result;
      }
      
      if (licenseData) {
        // Status based on isActive and isPaused
        let status = "Unknown";
        if (licenseData.isActive && !licenseData.isPaused) {
          status = "‚úÖ Active";
        } else if (licenseData.isPaused) {
          status = "‚è∏Ô∏è Paused";
        } else if (!licenseData.isActive) {
          status = "‚ùå Inactive";
        }
        
        embed.addFields({ name: "Status", value: status, inline: true });

        // Expiry from expiresAt
        if (licenseData.expiresAt) {
          const expiryDate = new Date(licenseData.expiresAt);
          const formattedExpiry = expiryDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
          embed.addFields({
            name: "Expiry",
            value: formattedExpiry,
            inline: true,
          });
        }
        
        // HWID if available
        if (licenseData.hwid) {
          embed.addFields({
            name: "HWID",
            value: `\`${licenseData.hwid}\``,
            inline: false,
          });
        }
      }

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Verification Failed",
            result.error || result.message || "License is invalid"
          ),
        ],
      });
    }
  }

  private async handleActivateLicense(
    interaction: ChatInputCommandInteraction
  ) {
    const license = interaction.options.getString("license", true);
    const hwid = interaction.options.getString("hwid", true);

    const result = await this.genzAuth.activateLicense(license, hwid);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "License Activated",
        result.message || "License activated successfully"
      );

      embed.addFields(
        { name: "License Key", value: `\`${license}\``, inline: false },
        { name: "HWID", value: `\`${hwid}\``, inline: false }
      );

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Activation Failed",
            result.error || result.message || "Failed to activate license"
          ),
        ],
      });
    }
  }

  private async handleDeleteLicense(interaction: ChatInputCommandInteraction) {
    const license = interaction.options.getString("license", true);

    const embed = this.createEmbed(
      "‚ö†Ô∏è Confirm Deletion",
      `Are you sure you want to delete this license? This action cannot be undone.`,
      "warning"
    );

    embed.addFields({
      name: "License to Delete",
      value: `\`${license}\``,
      inline: false,
    });

    const confirmationButtons = this.createConfirmationButtons("delete_license", license, interaction.user.id);

    await interaction.editReply({ 
      embeds: [embed], 
      components: [confirmationButtons] 
    });
  }

  private async handleBanLicense(interaction: ChatInputCommandInteraction) {
    const license = interaction.options.getString("license", true);

    const embed = this.createEmbed(
      "‚ö†Ô∏è Confirm Ban",
      `Are you sure you want to ban this license? This will prevent it from being used.`,
      "warning"
    );

    embed.addFields({
      name: "License to Ban",
      value: `\`${license}\``,
      inline: false,
    });

    const confirmationButtons = this.createConfirmationButtons("ban_license", license, interaction.user.id);

    await interaction.editReply({ 
      embeds: [embed], 
      components: [confirmationButtons] 
    });
  }

  private async handleCreateUser(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);
    const password = interaction.options.getString("password", true);
    const expiry = interaction.options.getInteger("expiry", true);

    const result = await this.genzAuth.createUser(username, password, expiry);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "User Created",
        result.message || "User created successfully"
      );

      embed.addFields(
        { name: "Username", value: `\`${username}\``, inline: true },
        { name: "Password", value: `\`${password}\``, inline: true },
        { name: "Expiry", value: `${expiry} days`, inline: true }
      );

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "User Creation Failed",
            result.error || result.message || "Failed to create user"
          ),
        ],
      });
    }
  }

  private async handleFetchUsers(interaction: ChatInputCommandInteraction, page: number = 0) {
    const result = await this.genzAuth.fetchAllUsers();

    if (result.success && result.data) {
      const ITEMS_PER_PAGE = 10;
      const totalPages = Math.ceil(result.data.length / ITEMS_PER_PAGE);
      const startIndex = page * ITEMS_PER_PAGE;
      const endIndex = startIndex + ITEMS_PER_PAGE;

      const embed = this.createInfoEmbed(
        "User List",
        `Total users: ${result.data.length}`
      );

      const paginatedUsers = result.data.slice(startIndex, endIndex);
      const userList = paginatedUsers.map((user: any, index: number) => {
        const globalIndex = startIndex + index + 1;
        
        let status = "Inactive";
        if (user.isActive && !user.isPaused) {
          status = "‚úÖ Active";
        } else if (user.isPaused) {
          status = "‚è∏Ô∏è Paused";
        } else if (!user.isActive) {
          status = "‚ùå Inactive";
        }
        
        let expiry = "N/A";
        if (user.expiresAt) {
          const expiryDate = new Date(user.expiresAt);
          expiry = expiryDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
        }
        
        return `**${globalIndex}.** ${user.username || "Unknown"}\n` +
          `‚îî‚îÄ Status: ${status} | Expiry: ${expiry}` +
          (user.hwid ? ` | HWID: \`${user.hwid.substring(0, 8)}...\`` : '');
      }).join("\n\n");

      if (userList) {
        embed.addFields({
          name: `Users (Page ${page + 1}/${totalPages})`,
          value: userList || "No users found",
          inline: false,
        });
      }

      const components = totalPages > 1 
        ? [this.createPaginationButtons(page, totalPages, "users")]
        : [];

      await interaction.editReply({ embeds: [embed], components });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Fetch Failed",
            result.error || result.message || "Failed to fetch users"
          ),
        ],
      });
    }
  }

  private async handleBanUser(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);

    const embed = this.createEmbed(
      "‚ö†Ô∏è Confirm User Ban",
      `Are you sure you want to ban this user? They will lose access to their account.`,
      "warning"
    );

    embed.addFields({
      name: "User to Ban",
      value: `\`${username}\``,
      inline: false,
    });

    const confirmationButtons = this.createConfirmationButtons("ban_user", username, interaction.user.id);

    await interaction.editReply({ 
      embeds: [embed], 
      components: [confirmationButtons] 
    });
  }

  private async handleUnbanUser(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);

    const result = await this.genzAuth.unbanUser(username);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "User Unbanned",
        result.message || "User unbanned successfully"
      );

      embed.addFields({
        name: "Unbanned User",
        value: `\`${username}\``,
        inline: false,
      });

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Unban Failed",
            result.error || result.message || "Failed to unban user"
          ),
        ],
      });
    }
  }

  private async handleDeleteUser(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);

    const embed = this.createEmbed(
      "‚ö†Ô∏è Confirm User Deletion",
      `Are you sure you want to delete this user? This will permanently remove all their data. This action cannot be undone.`,
      "warning"
    );

    embed.addFields({
      name: "User to Delete",
      value: `\`${username}\``,
      inline: false,
    });

    const confirmationButtons = this.createConfirmationButtons("delete_user", username, interaction.user.id);

    await interaction.editReply({ 
      embeds: [embed], 
      components: [confirmationButtons] 
    });
  }

  private async handleExtendUser(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);
    const days = interaction.options.getInteger("days", true);

    const result = await this.genzAuth.extendUser(username, days);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "User Extended",
        result.message || "User subscription extended successfully"
      );

      embed.addFields(
        { name: "Username", value: `\`${username}\``, inline: true },
        { name: "Extended By", value: `${days} days`, inline: true }
      );

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Extension Failed",
            result.error || result.message || "Failed to extend user"
          ),
        ],
      });
    }
  }

  private async handleResetHwid(interaction: ChatInputCommandInteraction) {
    const username = interaction.options.getString("username", true);

    const result = await this.genzAuth.resetHwid(username);

    if (result.success) {
      const embed = this.createSuccessEmbed(
        "HWID Reset",
        result.message || "HWID reset successfully"
      );

      embed.addFields({
        name: "Username",
        value: `\`${username}\``,
        inline: false,
      });

      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Reset Failed",
            result.error || result.message || "Failed to reset HWID"
          ),
        ],
      });
    }
  }

  private async handleFetchLicenses(interaction: ChatInputCommandInteraction, page: number = 0) {
    const result = await this.genzAuth.fetchAllLicenses();

    if (result.success && result.data) {
      const ITEMS_PER_PAGE = 10;
      const totalPages = Math.ceil(result.data.length / ITEMS_PER_PAGE);
      const startIndex = page * ITEMS_PER_PAGE;
      const endIndex = startIndex + ITEMS_PER_PAGE;

      const embed = this.createInfoEmbed(
        "License List",
        `Total licenses: ${result.data.length}`
      );

      const paginatedLicenses = result.data.slice(startIndex, endIndex);
      const licenseList = paginatedLicenses.map((license: any, index: number) => {
        const globalIndex = startIndex + index + 1;
        
        let status = "Unknown";
        if (license.isActive && !license.isPaused) {
          status = "‚úÖ Active";
        } else if (license.isPaused) {
          status = "‚è∏Ô∏è Paused";
        } else if (!license.isActive) {
          status = "‚ùå Inactive";
        }
        
        let expiry = "N/A";
        if (license.expiresAt) {
          const expiryDate = new Date(license.expiresAt);
          expiry = expiryDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
        }
        
        const licenseKey = license.key || license.licenseKey || "Unknown";
        return `**${globalIndex}.** \`${licenseKey}\`\n` +
          `‚îî‚îÄ Status: ${status} | Expiry: ${expiry}` +
          (license.hwid ? ` | HWID: \`${license.hwid.substring(0, 8)}...\`` : '');
      }).join("\n\n");

      if (licenseList) {
        embed.addFields({
          name: `Licenses (Page ${page + 1}/${totalPages})`,
          value: licenseList || "No licenses found",
          inline: false,
        });
      }

      const components = totalPages > 1 
        ? [this.createPaginationButtons(page, totalPages, "licenses")]
        : [];

      await interaction.editReply({ embeds: [embed], components });
    } else {
      await interaction.editReply({
        embeds: [
          this.createErrorEmbed(
            "Fetch Failed",
            result.error || result.message || "Failed to fetch licenses"
          ),
        ],
      });
    }
  }

  private async handleButtonInteraction(interaction: ButtonInteraction) {
    // Check if this is a confirmation button (uses ":::") or pagination button (uses "_")
    if (interaction.customId.includes(":::")) {
      // Handle confirmation/cancel buttons
      const parts = interaction.customId.split(":::");
      const [type, action, encodedPayload] = parts;

      // Handle cancel button
      if (type === "cancel") {
        const payload = JSON.parse(Buffer.from(encodedPayload, 'base64').toString('utf-8'));
        const initiatorId = payload.userId;

        // Check if the person clicking cancel is the initiator
        if (interaction.user.id !== initiatorId) {
          await interaction.reply({
            embeds: [
              this.createErrorEmbed(
                "Permission Denied",
                "Only the person who initiated this command can cancel it."
              )
            ],
            ephemeral: true,
          });
          return;
        }

        const user = interaction.user;
        this.logger.log({
          user: user.username,
          userId: user.id,
          operation: "CANCEL_OPERATION",
          success: true,
          message: "User cancelled a destructive operation",
        });

        await interaction.update({
          embeds: [
            this.createInfoEmbed("Operation Cancelled", "The operation was cancelled.")
          ],
          components: [],
        });
        return;
      }

      // Handle confirmation buttons - continue to existing confirmation logic
      await this.handleConfirmButton(interaction, action, encodedPayload);
    } else {
      // Handle pagination buttons (old format with "_")
      await this.handlePaginationInteraction(interaction);
    }
  }

  private async handleConfirmButton(interaction: ButtonInteraction, operationType: string, encodedPayload: string) {
    const payload = JSON.parse(Buffer.from(encodedPayload, 'base64').toString('utf-8'));
    const target = payload.target;
    const initiatorId = payload.userId;

    // Check if the person clicking confirm is the initiator
    if (interaction.user.id !== initiatorId) {
      await interaction.reply({
        embeds: [
          this.createErrorEmbed(
            "Permission Denied",
            "Only the person who initiated this command can confirm it."
          )
        ],
        ephemeral: true,
      });

      this.logger.log({
        user: interaction.user.username,
        userId: interaction.user.id,
        operation: `UNAUTHORIZED_${operationType.toUpperCase()}`,
        target,
        success: false,
        message: "User attempted to confirm action initiated by someone else",
      });
      return;
    }

    // Re-validate admin permissions using memberPermissions
    if (interaction.guild) {
      const hasAdminPermission = interaction.memberPermissions?.has(PermissionFlagsBits.Administrator);
      
      if (!hasAdminPermission) {
        await interaction.update({
          embeds: [
            this.createErrorEmbed(
              "Permission Denied",
              "You no longer have administrator permissions to perform this action."
            )
          ],
          components: [],
        });

        this.logger.log({
          user: interaction.user.username,
          userId: interaction.user.id,
          operation: operationType.toUpperCase(),
          target,
          success: false,
          message: "Permission denied - no longer has admin rights",
        });
        return;
      }
    }

    await interaction.deferUpdate();

    const user = interaction.user;
    let result;
    let embed;

      switch (operationType) {
        case "delete_license":
          result = await this.genzAuth.deleteLicense(target);
          this.logger.log({
            user: user.username,
            userId: user.id,
            operation: "DELETE_LICENSE",
            target,
            success: result.success || false,
            message: result.message || result.error || "License deletion attempt",
          });

          if (result.success) {
            embed = this.createSuccessEmbed(
              "License Deleted",
              result.message || "License deleted successfully"
            );
            embed.addFields({
              name: "Deleted License",
              value: `\`${target}\``,
              inline: false,
            });
          } else {
            embed = this.createErrorEmbed(
              "Deletion Failed",
              result.error || result.message || "Failed to delete license"
            );
          }
          break;

        case "ban_license":
          result = await this.genzAuth.banLicense(target);
          this.logger.log({
            user: user.username,
            userId: user.id,
            operation: "BAN_LICENSE",
            target,
            success: result.success || false,
            message: result.message || result.error || "License ban attempt",
          });

          if (result.success) {
            embed = this.createSuccessEmbed(
              "License Banned",
              result.message || "License banned successfully"
            );
            embed.addFields({
              name: "Banned License",
              value: `\`${target}\``,
              inline: false,
            });
          } else {
            embed = this.createErrorEmbed(
              "Ban Failed",
              result.error || result.message || "Failed to ban license"
            );
          }
          break;

        case "ban_user":
          result = await this.genzAuth.banUser(target);
          this.logger.log({
            user: user.username,
            userId: user.id,
            operation: "BAN_USER",
            target,
            success: result.success || false,
            message: result.message || result.error || "User ban attempt",
          });

          if (result.success) {
            embed = this.createSuccessEmbed(
              "User Banned",
              result.message || "User banned successfully"
            );
            embed.addFields({
              name: "Banned User",
              value: `\`${target}\``,
              inline: false,
            });
          } else {
            embed = this.createErrorEmbed(
              "Ban Failed",
              result.error || result.message || "Failed to ban user"
            );
          }
          break;

        case "delete_user":
          result = await this.genzAuth.deleteUser(target);
          this.logger.log({
            user: user.username,
            userId: user.id,
            operation: "DELETE_USER",
            target,
            success: result.success || false,
            message: result.message || result.error || "User deletion attempt",
          });

          if (result.success) {
            embed = this.createSuccessEmbed(
              "User Deleted",
              result.message || "User deleted successfully"
            );
            embed.addFields({
              name: "Deleted User",
              value: `\`${target}\``,
              inline: false,
            });
          } else {
            embed = this.createErrorEmbed(
              "Deletion Failed",
              result.error || result.message || "Failed to delete user"
            );
          }
          break;

        default:
          embed = this.createErrorEmbed("Unknown Operation", "This operation is not recognized.");
      }

      await interaction.editReply({ embeds: [embed], components: [] });
  }

  private async handlePaginationInteraction(interaction: ButtonInteraction) {
    const parts = interaction.customId.split("_");
    const type = parts[0];
    const action = parts[1];
    const currentPage = parseInt(parts[2]);
    let newPage = currentPage;
    
    if (action === "prev") {
      newPage = Math.max(0, currentPage - 1);
    } else if (action === "next") {
      newPage = currentPage + 1;
    } else {
      // Page indicator button, do nothing
      return;
    }

    await interaction.deferUpdate();

    // Re-fetch data and update the message
    if (type === "users") {
      const result = await this.genzAuth.fetchAllUsers();
      if (result.success && result.data) {
        const ITEMS_PER_PAGE = 10;
        const totalPages = Math.ceil(result.data.length / ITEMS_PER_PAGE);
        const startIndex = newPage * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;

        const embed = this.createInfoEmbed(
          "User List",
          `Total users: ${result.data.length}`
        );

        const paginatedUsers = result.data.slice(startIndex, endIndex);
        const userList = paginatedUsers.map((user: any, index: number) => {
          const globalIndex = startIndex + index + 1;
          
          let status = "Inactive";
          if (user.isActive && !user.isPaused) {
            status = "‚úÖ Active";
          } else if (user.isPaused) {
            status = "‚è∏Ô∏è Paused";
          } else if (!user.isActive) {
            status = "‚ùå Inactive";
          }
          
          let expiry = "N/A";
          if (user.expiresAt) {
            const expiryDate = new Date(user.expiresAt);
            expiry = expiryDate.toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'short', 
              day: 'numeric' 
            });
          }
          
          return `**${globalIndex}.** ${user.username || "Unknown"}\n` +
            `‚îî‚îÄ Status: ${status} | Expiry: ${expiry}` +
            (user.hwid ? ` | HWID: \`${user.hwid.substring(0, 8)}...\`` : '');
        }).join("\n\n");

        if (userList) {
          embed.addFields({
            name: `Users (Page ${newPage + 1}/${totalPages})`,
            value: userList,
            inline: false,
          });
        }

        const components = totalPages > 1 
          ? [this.createPaginationButtons(newPage, totalPages, "users")]
          : [];

        await interaction.editReply({ embeds: [embed], components });
      }
    } else if (type === "licenses") {
      const result = await this.genzAuth.fetchAllLicenses();
      if (result.success && result.data) {
        const ITEMS_PER_PAGE = 10;
        const totalPages = Math.ceil(result.data.length / ITEMS_PER_PAGE);
        const startIndex = newPage * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;

        const embed = this.createInfoEmbed(
          "License List",
          `Total licenses: ${result.data.length}`
        );

        const paginatedLicenses = result.data.slice(startIndex, endIndex);
        const licenseList = paginatedLicenses.map((license: any, index: number) => {
          const globalIndex = startIndex + index + 1;
          
          let status = "Unknown";
          if (license.isActive && !license.isPaused) {
            status = "‚úÖ Active";
          } else if (license.isPaused) {
            status = "‚è∏Ô∏è Paused";
          } else if (!license.isActive) {
            status = "‚ùå Inactive";
          }
          
          let expiry = "N/A";
          if (license.expiresAt) {
            const expiryDate = new Date(license.expiresAt);
            expiry = expiryDate.toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'short', 
              day: 'numeric' 
            });
          }
          
          const licenseKey = license.key || license.licenseKey || "Unknown";
          return `**${globalIndex}.** \`${licenseKey}\`\n` +
            `‚îî‚îÄ Status: ${status} | Expiry: ${expiry}` +
            (license.hwid ? ` | HWID: \`${license.hwid.substring(0, 8)}...\`` : '');
        }).join("\n\n");

        if (licenseList) {
          embed.addFields({
            name: `Licenses (Page ${newPage + 1}/${totalPages})`,
            value: licenseList,
            inline: false,
          });
        }

        const components = totalPages > 1 
          ? [this.createPaginationButtons(newPage, totalPages, "licenses")]
          : [];

        await interaction.editReply({ embeds: [embed], components });
      }
    }
  }

  async registerCommands(clientId: string) {
    const rest = new REST({ version: "10" }).setToken(this.token);

    try {
      console.log("üîÑ Registering slash commands...");

      await rest.put(Routes.applicationCommands(clientId), {
        body: this.commands.map((cmd) => cmd.toJSON()),
      });

      console.log("‚úÖ Successfully registered slash commands");
    } catch (error) {
      console.error("‚ùå Error registering commands:", error);
    }
  }

  async start() {
    await this.client.login(this.token);
  }

  getClient() {
    return this.client;
  }
}

export { DiscordBot };
